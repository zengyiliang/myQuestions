一、mysql 函数/存储过程/视图/触发器/表/外键
存储过程与函数的区别：
1）一般来说，存储过程实现的功能要复杂一点，而函数的实现的功能针对性比较强。存储过程，功能强大，可以执行包括修改表等一系列数据库操作；
2）对于存储过程来说可以返回参数，如记录集，而函数只能返回值或者表对象。
函数只能返回一个变量；而存储过程可以返回多个。存储过程的参数可以有IN,OUT,INOUT三种类型，而函数只能有IN类~~存储过程声明时不需要返回类型，
而函数声明时需要描述返回类型，且函数体中必须包含一个有效的RETURN语句。
3）存储过程，可以使用非确定函数，不允许在用户定义函数主体中内置非确定函数。
4）存储过程一般是作为一个独立的部分来执行（ EXECUTE 语句执行），而函数可以作为查询语句的一个部分来调用（SELECT调用），
由于函数可以返回一个表对象，因此它可以在查询语句中位于FROM关键字的后面。 SQL语句中不可用存储过程，而可以使用函数。

视图是数据库中由真实的数据表通过查询语句定义而成的一种虚拟表，视图本身不存储数据只是存储查询数据的定义
（1）. 比如你程序发送查询语句给数据库服务器的时候，用视图传输的语句字节数更少
（2）. 程序上的代码写的更少了，更容易读懂视图查询所需要的字段，不必考虑多表查询的细节
（3）. 多表更新字段或减少冗余时，你不必修改程序，只需要更新视图即可
安全：使用视图的用户只能访问他们被允许查询的结果集，对表的权限管理并不能限制到某个行某个列，但是通过视图就可以简单的实现。

触发器：

二、mysql 索引

三、mysql 存储引擎

四、mysql 锁机制 https://www.cnblogs.com/leedaily/p/8378779.html
MySQL的表级锁有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。
对MyISAM表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；
对 MyISAM表的写操作，则会阻塞其他用户对同一表的读和写操作；
MyISAM表的读操作与写操作之间，以及写操作之间是串行的！
如何加表锁：
MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，
这个过程并不需要用户干预

InnoDB与MyISAM的最大不同有两点：一是支持事务（TRANSACTION）；二是采用了行级锁。

不可重复读：A事务在执行过程中，B事务对数据进行了修改或删除，导致A两次读取的数据不一致；
重点在于update和delete（锁行即可解决），
幻读：A事务在执行过程中，B事务新增了符合A事务要查询的数据，导致A两次读取的数据不一致；
重点在于insert（需要锁表解决）。

只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！ 
在不通过索引条件查询的时候，InnoDB确实使用的是表锁，而不是行锁。